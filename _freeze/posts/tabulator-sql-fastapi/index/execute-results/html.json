{
  "hash": "ece074701547646a09c2cf298ff229cb",
  "result": {
    "markdown": "---\ntitle: \"Display data from a SQL source on the web with Tabulator and FastAPI\"\nsubtitle: \"With server side pagination and filtering\"\ncategories: [\"python\", \"web\", \"fastapi\", \"tabulator\", \"SQL\"]\ndate: \"2023-09-23\"\ntoc: true\nimage: \"preview.png\"\nformat:\n    html:\n        code-fold: false\nfilters:\n    - line-highlight\n    \n---\n\n# Introduction\n\nAt work we have an SQL database containing a list of alarms that are generated by different control systems. We usually receive Email and SMS notifications for that, but it's not easy to get an overview of all the alarms. We decided then to create a simple web application that wraps the data on the database and allows people from the team to easily access it.\n\nWhen thinking about the web applications I wanted to have the following requirements:\n\n* The alarms data should be only read, no modifications are required\n* The alarms data should be loaded with server side pagination, since the number of rows in the DB are ~O($10^4$) and I don't want to load them on the web page each time\n* The data should be displayed on a table that allows for custom filtering. The only way to do filtering with server side pagination is for the table to send the filter queries on the backend and do some sort of server side filtering\n* One of the columns should contains a link that open a page with all the details of the clicked alarm, like in a RESTful resource\n\n## Alternative tools\n\nI initially evaluated the possibility of using some python libraries like [streamlit](https://streamlit.io/), [panel](https://panel.holoviz.org/), [h2o-wave](https://wave.h2o.ai/), [plotly's dash](https://dash.plotly.com/), each one with a set of pros\nand cons. I decided to not use them because I felt that although using a data table is pretty easy (panel and dash support the use of tabulator for example), the server side pagination and filtering was a bit cumbersome. In addition, integrating the application with a python ASGI server started to be a bit too complicated to the point that having a single framework seemed\nthe cleanest solution to me.\n\nI have also considered few no-code tools that wrap any data around a web application. I have considered Apache's [superset](https://superset.apache.org/) which is a very powerful tool but it was probably an overkill.\nI have also though about using [directus](https://directus.io/) which works pretty ok but it adds metadata tables on your db and the filtering on the frontend is a bit cumbersome.\n\nI ultimately decided to invest some time and go back to the basics of python web frameworks and vanilla javascript libraries.\nIn the past I used [FastAPI](https://fastapi.tiangolo.com/tutorial/query-params/) for a RESTful web application and I found it quite enjoyable, especially for its clear and extensive documentation. Since the project partially requires to serve data from an REST interface I decided to go for it and use it again.\n\nOn the frontend I started googling for javascript data tables. I also saw that streamlit had a plugin for [AgGrid](https://www.ag-grid.com/) which seemed like an extremely powerful library but that requires a quite pricy license, so I decided to discard it. Some other options included [DataTables](https://datatables.net/) and [GridJs](https://gridjs.io/) but I ultimately ended up trying [tabulator](https://tabulator.info/) because I liked the documentation and the set of examples it provided.\n\n\n# Setting up the project\n\nIn this section I will detail the steps I've taken to create the web project. You can also have a look at the final example at the [demo repo on github](https://github.com/grigolet/tabulator-sql-fastapi-demo) for the final result.\n\n**DISCLAIMER**\n_I am not a web developer, I mainly work with gas systems and particle detectors. As such, my code may not be entirely safe and optimized for needs other than mine. Read, learn and use at your own risk ðŸ¤Œ_\n\nFirst thing, create a dedicated folder in which you can install your python virtual environment and application.\n```sh\nmkdir tabulator-sql-fastapi-demo \n```\nWe will work inside the `tabulator-sql-fastapi-demo` folder from now on.\nCreate a virtual environment and activate it\n```sh\ncd tabulator-sql-fastapi-demo \n```\n```sh\npython -m venv venv\n```\n```sh\nsource venv/bin/activate\n```\nCreate an `app` folder where we will put our code\n```sh\nmkdir app\n```\nLet's create a `requirements.txt` file and start putting FastAPI with all the optional dependencies:\n```{.text filename=\"requirements.txt\"}\nfastapi[all]\n```\n\n\n# Creating the initial backend\nLet's start by creating a server with three endpoints: a main one served on `/`, one called `/alarm` which will serve as a resource for a single alarm and an `/alarms` one which will serve multiple alarms\n\n::: {.cell class-source='numberLines' filename='main.py' source-line-numbers='2,6-7' execution_count=1}\n``` {.python .cell-code}\nfrom fastapi import FastAPI, Request\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def home(request: Request):\n    return {\"page\": \"home\"}\n\n\n@app.get(\"/alarm\")\nasync def home(request: Request):\n    return {\"page\": \"alarm\"}\n\n\n@app.get(\"/alarms\")\nasync def home(request: Request):\n    return {\"page\": \"alarms\"}\n```\n:::\n\n\nRun the main application:\n```sh\nuvicorn app.main:app --reload\n```\nIf you open your web browser at the link mentioned by `uvicorn` you should get the json response for each of the endpoint defined, e.g.\n```{.json filename=\"http://127.0.0.1:8000/alarms\"}\n{\n  \"page\": \"alarms\"\n}\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}