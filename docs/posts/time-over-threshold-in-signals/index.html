<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-09-30">

<title>G.R.’s Blog - Time Over Threshold in signal processing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="G.R.’s Blog - Time Over Threshold in signal processing">
<meta property="og:description" content="A useful indicator of your signal dynamics">
<meta property="og:image" content="https://grigolet.github.io/posts/time-over-threshold-in-signals/graph.png">
<meta property="og:site-name" content="G.R.'s Blog">
<meta property="og:image:height" content="297">
<meta property="og:image:width" content="647">
<meta name="twitter:title" content="G.R.’s Blog - Time Over Threshold in signal processing">
<meta name="twitter:description" content="A useful indicator of your signal dynamics">
<meta name="twitter:image" content="https://grigolet.github.io/posts/time-over-threshold-in-signals/graph.png">
<meta name="twitter:image-height" content="297">
<meta name="twitter:image-width" content="647">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">G.R.’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/grigolet" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/gianrigoletti" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Time Over Threshold in signal processing</h1>
            <p class="subtitle lead">A useful indicator of your signal dynamics</p>
                                <div class="quarto-categories">
                <div class="quarto-category">python</div>
                <div class="quarto-category">matplotlib</div>
                <div class="quarto-category">scipy</div>
                <div class="quarto-category">numpy</div>
                <div class="quarto-category">signal processing</div>
                <div class="quarto-category">signal analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 30, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#tot-by-taking-the-closest-samples" id="toc-tot-by-taking-the-closest-samples" class="nav-link" data-scroll-target="#tot-by-taking-the-closest-samples">ToT by taking the closest samples</a>
  <ul class="collapse">
  <li><a href="#the-1d-case" id="toc-the-1d-case" class="nav-link" data-scroll-target="#the-1d-case">The 1d case</a></li>
  <li><a href="#the-2d-case" id="toc-the-2d-case" class="nav-link" data-scroll-target="#the-2d-case">The 2d case</a></li>
  </ul></li>
  <li><a href="#a-more-accurate-time-over-threshold-by-linear-interpolation" id="toc-a-more-accurate-time-over-threshold-by-linear-interpolation" class="nav-link" data-scroll-target="#a-more-accurate-time-over-threshold-by-linear-interpolation">A more accurate time over threshold by linear interpolation</a>
  <ul class="collapse">
  <li><a href="#the-1d-case-1" id="toc-the-1d-case-1" class="nav-link" data-scroll-target="#the-1d-case-1">The 1d case</a></li>
  <li><a href="#the-2d-case-1" id="toc-the-2d-case-1" class="nav-link" data-scroll-target="#the-2d-case-1">The 2d case</a></li>
  <li><a href="#handling-corner-cases" id="toc-handling-corner-cases" class="nav-link" data-scroll-target="#handling-corner-cases">Handling corner cases</a></li>
  </ul></li>
  <li><a href="#why-i-needed-linear-interpolation" id="toc-why-i-needed-linear-interpolation" class="nav-link" data-scroll-target="#why-i-needed-linear-interpolation">Why I needed linear interpolation</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>A part of my work consists of acquiring the signal induced on a set of copper strips of a gaseous detectors. The signals dynamics such as the height, shape, duration, typically give useful information about what is going on inside the detector. The signal generated by a gasesous detector depends on several factors: - he geometry, layout and working principle of the detector itself; - the electric field applied in the gas medium that allows for the electron created by an ionizing particle to start an avalanche process and move a sufficiently high number of electrons to be detected by the electronics; - the gas used, which greatly affects the dynamic of the avalanche development</p>
<p>Among all of these parameters, I would like to focus on one: the time over threshold. The time over threshold can be defined in different ways. For simplicity, I will define it as the difference of the time between the signal first and last crosses a fixed treshold.</p>
<p>For example, look at the plot <a href="#fig-waveforms">Figure&nbsp;1</a></p>
<div class="cell" data-execution_count="25">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># The holy trininty of libraries that will be used</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co"># throughout the post</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># Just to set the maximum of items to be printed for an array</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>np.set_printoptions(threshold<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"># A better style for plots</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>plt.style.use(<span class="st">'https://gitlab.cern.ch/-/snippets/2223/raw/master/rpcecogas.mplstyle'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>window_length <span class="op">=</span> <span class="dv">520</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"># This file contains 10 waveforms of 520 samples. Each sample is written on a single line</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>df <span class="op">=</span> pd.read_csv(<span class="st">"https://gist.githubusercontent.com/grigolet/09ffada96abb2acf0fe34070f0e83211/raw/3880aa89e4b113ea2866ec8e3768c03e98f84118/signals.txt"</span>,</span>
<span id="cb2-4"><a href="#cb2-4"></a>                header<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span>[<span class="st">'waveform'</span>])</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># in the next line I will transform the dataframe into a 2d</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co"># numpy array with shape (number of signals, window length).</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>waveforms <span class="op">=</span> df.waveform.values.reshape((<span class="op">-</span><span class="dv">1</span>, window_length))</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb2-10"><a href="#cb2-10"></a>ax.plot(waveforms.T)<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Time [2 ns]'</span>, ylabel<span class="op">=</span><span class="st">'ADC [a.u.]'</span>, title<span class="op">=</span><span class="st">'Waveforms'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-waveforms" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/fig-waveforms-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Waveform read-out from a gaseous detector</figcaption>
</figure>
</div>
</div>
</div>
<p>Image that we would like to compute the duration of all the signals below a threshold that I arbitrarly fix. For example:</p>
<div class="cell" data-execution_count="201">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Prepare and read the data</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>window_length <span class="op">=</span> <span class="dv">520</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>threshold <span class="op">=</span> <span class="dv">8235</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># This file contains 10 waveforms of 520 samples. Each sample is written on a single line</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>df <span class="op">=</span> pd.read_csv(<span class="st">"https://gist.githubusercontent.com/grigolet/09ffada96abb2acf0fe34070f0e83211/raw/3880aa89e4b113ea2866ec8e3768c03e98f84118/signals.txt"</span>,</span>
<span id="cb3-6"><a href="#cb3-6"></a>                header<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span>[<span class="st">'waveform'</span>])</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"># in the next line I will transform the dataframe into a 2d</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co"># numpy array with shape (number of signals, window length).</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>waveforms <span class="op">=</span> df.waveform.values.reshape((<span class="op">-</span><span class="dv">1</span>, window_length))</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="cf">for</span> ix, waveform <span class="kw">in</span> <span class="bu">enumerate</span>(waveforms):</span>
<span id="cb3-13"><a href="#cb3-13"></a>    ax.plot(waveform, label<span class="op">=</span><span class="ss">f"Waveform </span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-14"><a href="#cb3-14"></a>ax.axhline(threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb3-15"><a href="#cb3-15"></a>ax.legend(loc<span class="op">=</span><span class="st">'upper left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb3-16"><a href="#cb3-16"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Time [2 ns]'</span>, ylabel<span class="op">=</span><span class="st">'ADC [a.u.]'</span>, title<span class="op">=</span><span class="ss">f'Waveforms. Threshold at </span><span class="sc">{</span>threshold<span class="sc">}</span><span class="ss">'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="tot-by-taking-the-closest-samples" class="level1">
<h1>ToT by taking the closest samples</h1>
<section id="the-1d-case" class="level2">
<h2 class="anchored" data-anchor-id="the-1d-case">The 1d case</h2>
<p>In this case, the easiest and probably more natual approach to compute the ToT would be to get the first sample below the threshold, the last sample below the threshold and do a difference.</p>
<p>This is fairly straightforward in the case of a single signal and it can be accomplished in few different ways:</p>
<div class="cell" data-execution_count="40">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># From the previous cell we have waveforms available in a 2d</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"># numpy array of shape (n waveforms, n samples)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"># I will take waveform 8 just for example purposes</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>threshold <span class="op">=</span> <span class="dv">8235</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>waveform <span class="op">=</span> waveforms[<span class="dv">8</span>, :]</span>
<span id="cb4-7"><a href="#cb4-7"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb4-8"><a href="#cb4-8"></a>ax.plot(waveform)</span>
<span id="cb4-9"><a href="#cb4-9"></a>ax.axhline(threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>&lt;matplotlib.lines.Line2D at 0x7fb662c0cd90&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-5-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>For the way I defined the time over threshold, I would have to take the first sample before crossing the threshold and the last one before going back</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>samples_below_threshold <span class="op">=</span> waveform <span class="op">&lt;</span> threshold</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co"># Boolean array indicating which sample is below the threshold</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>samples_below_threshold</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>array([False, False, False, ..., False, False, False])</code></pre>
</div>
</div>
<p>If I imagine the boolean array defined above as an integer array, I could use <code>np.argmax()</code> to find the first item for which the condition is true, i.e.&nbsp;the first item crossing the threshold.</p>
<p>To find instead the last item I could use <code>np.argmax()</code> but applied to the reversed array, taking into account that the resulting index should be then subtracted with the number of samples of the waveform</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>first_item <span class="op">=</span> np.argmax(samples_below_threshold)</span>
<span id="cb8-2"><a href="#cb8-2"></a>last_item <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[::<span class="op">-</span><span class="dv">1</span>]) <span class="op">-</span><span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>first_item, last_item</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb8-6"><a href="#cb8-6"></a>ax.plot(waveform)</span>
<span id="cb8-7"><a href="#cb8-7"></a>ax.axhline(threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb8-8"><a href="#cb8-8"></a>ax.axvline(first_item, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb8-9"><a href="#cb8-9"></a>ax.axvline(last_item, color<span class="op">=</span><span class="st">'r'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>&lt;matplotlib.lines.Line2D at 0x7fb662bb13f0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-7-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="the-2d-case" class="level2">
<h2 class="anchored" data-anchor-id="the-2d-case">The 2d case</h2>
<p>In a case of a 2d array like <code>waveforms</code>, some numpy gym can be used to perform vectorized operation and avoid using <code>for</code> loops.</p>
<p>A trick I often used to remember on which axis I want to perform an operation on a <code>numpy.ndarray</code>: if the numpy array has a shape (x_dim, y_dim, z_dim, …) then the operation I perform the aggregation on is making that axis collapse.</p>
<p>So in the present case, if I have an <code>(n_waveforms, n_samples)</code> array, then I would expect to have the <code>argmax()</code> of each waveform, so an array with a shape <code>(n_waveforms)</code>. This means that <code>axis=0</code> should be preversed and <code>axis=1</code> should collapse, so the <code>np.argmax()</code> operation should have <code>axis=1</code>.</p>
<p>It’s a bit tricky but it’s working fine in my mental model</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># Now we have a 2d array of waveforms but</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"># an analogue boolean mask</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>samples_below_threshold</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>first_items <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co"># Reverse the array over the samples dimensions to get the last </span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co"># point of threshold crossing</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>last_items <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="bu">print</span>(first_items, last_items)</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co"># Let's graphically check the results</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="cf">for</span> ix, waveform <span class="kw">in</span> <span class="bu">enumerate</span>(waveforms):</span>
<span id="cb10-16"><a href="#cb10-16"></a>    ax.plot(waveform, label<span class="op">=</span><span class="ss">f"Waveform </span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>    ax.plot(first_items[ix], threshold, <span class="ss">f'C</span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb10-18"><a href="#cb10-18"></a>    ax.plot(last_items[ix], threshold, <span class="ss">f'C</span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb10-19"><a href="#cb10-19"></a>ax.legend(loc<span class="op">=</span><span class="st">'upper left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb10-20"><a href="#cb10-20"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Time [2 ns]'</span>, ylabel<span class="op">=</span><span class="st">'ADC [a.u.]'</span>, title<span class="op">=</span><span class="ss">f'Waveforms. Threshold at </span><span class="sc">{</span>threshold<span class="sc">}</span><span class="ss">'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[227   0 232 ... 236 249   0] [230 519 237 ... 240 346 519]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-8-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>In the example above I marked the points at which the threshold is crossed. However, in the case of a waveform not crossing the threshold, the <code>np.argmax()</code> function would return 0, so <code>first_item</code> would be equal to 0 and <code>last_item</code> would be equal to <code>window_length - 1</code>, as it is for the 9th waveform:</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>n_waveform <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>waveform <span class="op">=</span> waveforms[n_waveform, :]</span>
<span id="cb12-3"><a href="#cb12-3"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="bu">print</span>(first_items[n_waveform], last_items[n_waveform])</span>
<span id="cb12-6"><a href="#cb12-6"></a>ax.plot(waveform)</span>
<span id="cb12-7"><a href="#cb12-7"></a>ax.axhline(threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0 519</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="66">
<pre><code>&lt;matplotlib.lines.Line2D at 0x7fb66347db40&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-9-output-3.png" class="img-fluid"></p>
</div>
</div>
<p>So at this step the time over threshold can be simply computed as <code>last_items - first_items</code>, discarding the values equal to <code>window_length - 1</code></p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>time_over_threshold <span class="op">=</span> last_items <span class="op">-</span> first_items</span>
<span id="cb15-2"><a href="#cb15-2"></a>time_over_threshold[time_over_threshold <span class="op">&lt;</span> (window_length  <span class="op">-</span> <span class="dv">1</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre><code>array([ 3,  5,  1, 69,  4, 97])</code></pre>
</div>
</div>
</section>
</section>
<section id="a-more-accurate-time-over-threshold-by-linear-interpolation" class="level1">
<h1>A more accurate time over threshold by linear interpolation</h1>
<p>The definition of time over threshold in the cases defined above is working well when the average value of this parameter is significantly sufficienclty high. This would mean that the sampling frequency (or the digitizer resolution) are good enough for this timing measurements.</p>
<p>Some other times, the sampling frequency is not so high and the signals are quite fasts, meaning that their time over threshold is getting smaller and smaller. An idea to improve the time resolution could be to precisely compute the intersection between the threshold viewed as an horizontal line and the segment formed by the sample before and after crossing the threshold.</p>
<p>I will label the coordinates of the points for which the threshold is first crossed with and <code>f</code> for <code>first</code> and the lasts with an <code>l</code> for <code>last</code>. The coordinates that are found before the threshold is passed are labelled with <code>b</code> for <code>before</code> and the ones found just after meeting the threshold are labeled with an <code>a</code> for <code>after</code>. The points we are interested in are the x intersection of the first intersection, that I will call <span class="math inline">\(x_f\)</span> and the one of the last that will be called <span class="math inline">\(x_l\)</span>. The time over threshold would be defined by the difference <span class="math inline">\(x_l - x_f\)</span>. I will call the threshold <span class="math inline">\(y_t\)</span>.</p>
<p>The labeling might be a bit confusing but I will leave here an image to make things clearer:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="graph.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Nomenclature used hereafter.</figcaption>
</figure>
</div>
<section id="the-1d-case-1" class="level2">
<h2 class="anchored" data-anchor-id="the-1d-case-1">The 1d case</h2>
<p>In this case I could set up the code in this way:</p>
<ol type="1">
<li>Find the coordinates before meeting the thresholds, i.e.&nbsp;<span class="math inline">\((x_{fb}, y_{fb})\)</span> and <span class="math inline">\((x_{lb}, y_{lb})\)</span></li>
<li>Find the coordinates after meeting the thresholds, i.e.&nbsp;<span class="math inline">\((x_{fa}, y_{fa})\)</span> and <span class="math inline">\((x_{la}, y_{la})\)</span></li>
<li>Find <span class="math inline">\(x_f\)</span> using some simple line equation: <span class="math display">\[
\frac{x_f- x_{fb}}{y_t - y_{fb}} = \frac{x_{fa} - x_{fb}}{y_{fa} - y_{fb}}
\]</span> <span class="math display">\[
x_f = x_{fb} + (x_{fa} - x_{fb}) \left(\frac{y_t - y_{fb}}{y_{fa} - y_{fb}}\right)
\]</span> In a similar way, for <span class="math inline">\(x_l\)</span>: <span class="math display">\[
x_l = x_{lb} + (x_{la} - x_{lb}) \left(\frac{y_t - y_{fb}}{y_{la} - y_{lb}}\right)
\]</span></li>
<li>Calculate the time over threshold as <span class="math inline">\(x_l - x_f\)</span></li>
</ol>
<div class="cell" data-execution_count="287">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># I'm taking the threshold as before as an example</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>waveform <span class="op">=</span> waveforms[<span class="dv">8</span>, :]</span>
<span id="cb17-3"><a href="#cb17-3"></a>samples_below_threshold <span class="op">=</span> waveform <span class="op">&lt;</span> threshold</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co"># Find the indices xfb and xlb</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>xfb <span class="op">=</span> np.argmax(samples_below_threshold) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[::<span class="op">-</span><span class="dv">1</span>]) <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="co"># The corresponding yfb and ylb are easy to get:</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>yfb, ylb <span class="op">=</span> waveform[xfb], waveform[xlb]</span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="co"># Now we can also find the coordinates of the samples</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="co"># after meeting the threshold</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>xfa, yfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span>, waveform[xfb <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb17-12"><a href="#cb17-12"></a>xla, yla <span class="op">=</span> xlb <span class="op">+</span> <span class="dv">1</span>, waveform[xlb <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co"># Find xf and xl</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>xf <span class="op">=</span> xfb <span class="op">+</span> (xfa <span class="op">-</span> xfb) <span class="op">*</span> ((threshold <span class="op">-</span> yfb) <span class="op">/</span> (yfa <span class="op">-</span> yfb))</span>
<span id="cb17-15"><a href="#cb17-15"></a>xl <span class="op">=</span> xlb <span class="op">+</span> (xla <span class="op">-</span> xlb) <span class="op">*</span> ((threshold <span class="op">-</span> ylb) <span class="op">/</span> (yla <span class="op">-</span> ylb))</span>
<span id="cb17-16"><a href="#cb17-16"></a>time_over_threshold <span class="op">=</span> xl <span class="op">-</span> xf</span>
<span id="cb17-17"><a href="#cb17-17"></a></span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="co"># Let's visualize everything</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb17-20"><a href="#cb17-20"></a>ax.plot(waveform, <span class="st">'.-'</span>)</span>
<span id="cb17-21"><a href="#cb17-21"></a>ax.axvline(xfb, color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb17-22"><a href="#cb17-22"></a>ax.axvline(xf, color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb17-23"><a href="#cb17-23"></a>ax.axvline(xfa, color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb17-24"><a href="#cb17-24"></a></span>
<span id="cb17-25"><a href="#cb17-25"></a>ax.axvline(xlb, color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb17-26"><a href="#cb17-26"></a>ax.axvline(xl, color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb17-27"><a href="#cb17-27"></a>ax.axvline(xla, color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb17-28"><a href="#cb17-28"></a></span>
<span id="cb17-29"><a href="#cb17-29"></a>ax.axhline(threshold, color<span class="op">=</span><span class="st">'C1'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb17-30"><a href="#cb17-30"></a></span>
<span id="cb17-31"><a href="#cb17-31"></a><span class="co"># zoom in in the region of interest</span></span>
<span id="cb17-32"><a href="#cb17-32"></a>ax.<span class="bu">set</span>(xlim<span class="op">=</span>(xfb <span class="op">-</span> <span class="dv">5</span>, xla <span class="op">+</span> <span class="dv">5</span>), title<span class="op">=</span><span class="ss">f'Time over threshold = </span><span class="sc">{</span>time_over_threshold<span class="sc">:.1f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="287">
<pre><code>[(243.0, 351.0), Text(0.5, 1.0, 'Time over threshold = 96.4')]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-11-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>As expected, the time over threshold is now computed as the intersection between the horizontal lines and the segments first and last crossing the threshold. The code above is failing in case the threshold is not crossing any segment:</p>
<div class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># Waveform 9 is not crossing the threshold</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>waveform <span class="op">=</span> waveforms[<span class="dv">9</span>, :]</span>
<span id="cb19-3"><a href="#cb19-3"></a>samples_below_threshold <span class="op">=</span> waveform <span class="op">&lt;</span> threshold</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co"># np.argmax returns 0 if nothing is found</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>xfb <span class="op">=</span> np.argmax(samples_below_threshold) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="co"># This would generated some issues because it's 520 - 0 = 520 </span></span>
<span id="cb19-7"><a href="#cb19-7"></a>xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[::<span class="op">-</span><span class="dv">1</span>]) </span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="co"># This part will throw an error because waveform has only</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="co"># 520 samples and waveform[520] is outside range</span></span>
<span id="cb19-10"><a href="#cb19-10"></a>yfb, ylb <span class="op">=</span> waveform[xfb], waveform[xlb]</span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="co"># ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>IndexError: index 520 is out of bounds for axis 0 with size 520</code></pre>
</div>
</div>
<p>The code is failing because it’s not possible to find the x coordinates for the segment last crossing the threshold. This results in a value of <span class="math inline">\(x_{lb}\)</span> of 520 that is outside the range of the array (which starts from 0 to 519). A possible solution could be to set the values of <span class="math inline">\(x_{lb}\)</span> to be 0 or <code>np.nan</code> in case they are found to be 520. This would result in a time over threshold of 0. This is the cleaniest solution I could find:</p>
<div class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>waveform <span class="op">=</span> waveforms[<span class="dv">9</span>, :]</span>
<span id="cb21-2"><a href="#cb21-2"></a>samples_below_threshold <span class="op">=</span> waveform <span class="op">&lt;</span> threshold</span>
<span id="cb21-3"><a href="#cb21-3"></a>xfb <span class="op">=</span> np.argmax(samples_below_threshold) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co"># Set xfb to be nan in case no threshold crossing</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="co"># is found. The same for xlb</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb21-7"><a href="#cb21-7"></a>xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[::<span class="op">-</span><span class="dv">1</span>]) </span>
<span id="cb21-8"><a href="#cb21-8"></a>xlb <span class="op">=</span> np.where(xlb <span class="op">!=</span> window_length, xlb, <span class="dv">0</span>)</span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="co"># The corresponding yfb and ylb are easy to get:</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>yfb, ylb <span class="op">=</span> waveform[xfb], waveform[xlb]</span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="co"># ... time over threshold will result in a 0 value</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="the-2d-case-1" class="level2">
<h2 class="anchored" data-anchor-id="the-2d-case-1">The 2d case</h2>
<p>The 2d case is a bit more complicated as it involves the usual <code>numpy</code> model to solve this problem in an efficient way. Nevertheless, the steps to approach the problem are the same so the code looks like the following:</p>
<div class="cell" data-execution_count="286">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="co"># Find the indices xfb and xlb</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>xfb <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="co"># Add np.where condition to handle signal without threshold crossing</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb22-6"><a href="#cb22-6"></a>xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>xlb <span class="op">=</span> np.where(xlb <span class="op">!=</span> window_length, xlb, <span class="dv">0</span>)</span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="co"># Taking indices along a 2d array is a bit</span></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="co"># more complicated. There are few different</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="co"># ways to do it</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>yfb <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb22-12"><a href="#cb22-12"></a>ylb <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a>xfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>yfa <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb22-16"><a href="#cb22-16"></a>xla <span class="op">=</span> xlb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-17"><a href="#cb22-17"></a>yla <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb22-18"><a href="#cb22-18"></a></span>
<span id="cb22-19"><a href="#cb22-19"></a>xf <span class="op">=</span> xfb <span class="op">+</span> (xfa <span class="op">-</span> xfb) <span class="op">*</span> ((threshold <span class="op">-</span> yfb) <span class="op">/</span> (yfa <span class="op">-</span> yfb))</span>
<span id="cb22-20"><a href="#cb22-20"></a>xl <span class="op">=</span> xlb <span class="op">+</span> (xla <span class="op">-</span> xlb) <span class="op">*</span> ((threshold <span class="op">-</span> ylb) <span class="op">/</span> (yla <span class="op">-</span> ylb))</span>
<span id="cb22-21"><a href="#cb22-21"></a>time_over_threshold <span class="op">=</span> xl <span class="op">-</span> xf</span>
<span id="cb22-22"><a href="#cb22-22"></a></span>
<span id="cb22-23"><a href="#cb22-23"></a><span class="co"># Let's visualize everything</span></span>
<span id="cb22-24"><a href="#cb22-24"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span><span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span><span class="dv">3</span>))</span>
<span id="cb22-25"><a href="#cb22-25"></a><span class="cf">for</span> ix, waveform <span class="kw">in</span> <span class="bu">enumerate</span>(waveforms):</span>
<span id="cb22-26"><a href="#cb22-26"></a>    ax <span class="op">=</span> axs.flat[ix]</span>
<span id="cb22-27"><a href="#cb22-27"></a>    ax.plot(waveform, <span class="st">'.-'</span>)</span>
<span id="cb22-28"><a href="#cb22-28"></a>    ax.axvline(xfb[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb22-29"><a href="#cb22-29"></a>    ax.axvline(xf[ix], color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb22-30"><a href="#cb22-30"></a>    ax.axvline(xfa[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb22-31"><a href="#cb22-31"></a></span>
<span id="cb22-32"><a href="#cb22-32"></a>    ax.axvline(xlb[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb22-33"><a href="#cb22-33"></a>    ax.axvline(xl[ix], color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb22-34"><a href="#cb22-34"></a>    ax.axvline(xla[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb22-35"><a href="#cb22-35"></a></span>
<span id="cb22-36"><a href="#cb22-36"></a>    ax.axhline(threshold, color<span class="op">=</span><span class="st">'C1'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb22-37"><a href="#cb22-37"></a></span>
<span id="cb22-38"><a href="#cb22-38"></a>    ax.<span class="bu">set</span>(xlim<span class="op">=</span>(xfb[ix] <span class="op">-</span> <span class="dv">5</span>, xla[ix] <span class="op">+</span> <span class="dv">5</span>), </span>
<span id="cb22-39"><a href="#cb22-39"></a>    ylim<span class="op">=</span>(threshold <span class="op">-</span> <span class="dv">20</span>, threshold <span class="op">+</span> <span class="dv">20</span>),</span>
<span id="cb22-40"><a href="#cb22-40"></a>    title<span class="op">=</span><span class="ss">f'Waveform </span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">.</span><span class="ch">\n</span><span class="ss">Time over threshold = </span><span class="sc">{</span>time_over_threshold[ix]<span class="sc">:.1f}</span><span class="ss"> samples'</span>)</span>
<span id="cb22-41"><a href="#cb22-41"></a>    fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_389329/2995661854.py:20: RuntimeWarning: divide by zero encountered in true_divide
  xl = xlb + (xla - xlb) * ((threshold - ylb) / (yla - ylb))</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-14-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>You may notice that there are few corner cases that may arise. For instance, have a look at waveform 5: the resulting time over threshold is <code>nan</code>. In this case, if the segment defined by <span class="math inline">\((x_{lb}, y_{lb}), (x_{la}, y_{la})\)</span> and crossing the threshold is parallel to the threshold itself, the values of either <span class="math inline">\(y_{fa} - y_{fb}\)</span> or <span class="math inline">\(y_{la} - y_{lb}\)</span> are equal to 0, resulting in an error similar to:</p>
<pre><code>RuntimeWarning: invalid value encountered in true_divide
  xl = xlb + (xla - xlb) * ((threshold - ylb) / (yla - ylb))</code></pre>
<p>A possible solution to this is to handle the division using <code>np.divide</code>, which allows to use a <code>where</code> option and that allows to avoid to <code>try/catch</code> or use a context manager to handle the error. For more information see this <a href="https://stackoverflow.com/questions/26248654/how-to-return-0-with-divide-by-zero">Stack overflow post</a>.</p>
<p>The code above will become the following:</p>
<div class="cell" data-execution_count="285">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="co"># Find the indices xfb and xlb</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>xfb <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co"># Add np.where condition to handle signal without threshold crossing</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb25-6"><a href="#cb25-6"></a>xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>xlb <span class="op">=</span> np.where(xlb <span class="op">!=</span> window_length, xlb, <span class="dv">0</span>)</span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="co"># Taking indices along a 2d array is a bit</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="co"># more complicated. There are few different</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="co"># ways to do it</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>yfb <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb25-12"><a href="#cb25-12"></a>ylb <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb25-13"><a href="#cb25-13"></a></span>
<span id="cb25-14"><a href="#cb25-14"></a>xfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb25-15"><a href="#cb25-15"></a>yfa <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb25-16"><a href="#cb25-16"></a>xla <span class="op">=</span> xlb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>yla <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb25-18"><a href="#cb25-18"></a></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co"># temp_yf and temp_yl are the arrays to use in case the 'where' condition is False. </span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="co"># If the 'where' condition is true, then the np.divide() result is used instead</span></span>
<span id="cb25-21"><a href="#cb25-21"></a>temp_yf, temp_yl <span class="op">=</span> np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), np.zeros_like(ylb, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb25-22"><a href="#cb25-22"></a>xf <span class="op">=</span> xfb <span class="op">+</span> (xfa <span class="op">-</span> xfb) <span class="op">*</span> (np.divide((threshold <span class="op">-</span> yfb) , (yfa <span class="op">-</span> yfb), out<span class="op">=</span>temp_yf, where<span class="op">=</span>(yfa <span class="op">-</span> yfb) <span class="op">!=</span> <span class="dv">0</span>))</span>
<span id="cb25-23"><a href="#cb25-23"></a>xl <span class="op">=</span> xlb <span class="op">+</span> (xla <span class="op">-</span> xlb) <span class="op">*</span> (np.divide((threshold <span class="op">-</span> ylb) , (yla <span class="op">-</span> ylb), out<span class="op">=</span>temp_yl, where<span class="op">=</span>(yla <span class="op">-</span> ylb) <span class="op">!=</span> <span class="dv">0</span>))</span>
<span id="cb25-24"><a href="#cb25-24"></a>time_over_threshold <span class="op">=</span> xl <span class="op">-</span> xf</span>
<span id="cb25-25"><a href="#cb25-25"></a></span>
<span id="cb25-26"><a href="#cb25-26"></a><span class="co"># Let's visualize everything</span></span>
<span id="cb25-27"><a href="#cb25-27"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span><span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span><span class="dv">3</span>))</span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="cf">for</span> ix, waveform <span class="kw">in</span> <span class="bu">enumerate</span>(waveforms):</span>
<span id="cb25-29"><a href="#cb25-29"></a>    ax <span class="op">=</span> axs.flat[ix]</span>
<span id="cb25-30"><a href="#cb25-30"></a>    ax.plot(waveform, <span class="st">'.-'</span>)</span>
<span id="cb25-31"><a href="#cb25-31"></a>    ax.axvline(xfb[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb25-32"><a href="#cb25-32"></a>    ax.axvline(xf[ix], color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb25-33"><a href="#cb25-33"></a>    ax.axvline(xfa[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb25-34"><a href="#cb25-34"></a></span>
<span id="cb25-35"><a href="#cb25-35"></a>    ax.axvline(xlb[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb25-36"><a href="#cb25-36"></a>    ax.axvline(xl[ix], color<span class="op">=</span><span class="st">'C2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb25-37"><a href="#cb25-37"></a>    ax.axvline(xla[ix], color<span class="op">=</span><span class="st">'C3'</span>)</span>
<span id="cb25-38"><a href="#cb25-38"></a></span>
<span id="cb25-39"><a href="#cb25-39"></a>    ax.axhline(threshold, color<span class="op">=</span><span class="st">'C1'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb25-40"><a href="#cb25-40"></a></span>
<span id="cb25-41"><a href="#cb25-41"></a>    ax.<span class="bu">set</span>(xlim<span class="op">=</span>(xfb[ix] <span class="op">-</span> <span class="dv">5</span>, xla[ix] <span class="op">+</span> <span class="dv">5</span>), </span>
<span id="cb25-42"><a href="#cb25-42"></a>    ylim<span class="op">=</span>(threshold <span class="op">-</span> <span class="dv">20</span>, threshold <span class="op">+</span> <span class="dv">20</span>),</span>
<span id="cb25-43"><a href="#cb25-43"></a>    title<span class="op">=</span><span class="ss">f'Waveform </span><span class="sc">{</span>ix<span class="sc">}</span><span class="ss">.</span><span class="ch">\n</span><span class="ss">Time over threshold = </span><span class="sc">{</span>time_over_threshold[ix]<span class="sc">:.1f}</span><span class="ss"> samples'</span>)</span>
<span id="cb25-44"><a href="#cb25-44"></a>    fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="handling-corner-cases" class="level2">
<h2 class="anchored" data-anchor-id="handling-corner-cases">Handling corner cases</h2>
<p>Unfortunately, the code below does not handle all the cases. Let’s wrap the previous code into a function and prepare some test cases</p>
<div class="cell" data-execution_count="508">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">def</span> compute_time_over_threshold(data: np.ndarray, threshold: <span class="bu">float</span> <span class="op">|</span> <span class="bu">int</span> <span class="op">|</span> np.ndarray) <span class="op">-&gt;</span> np.ndarray: </span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="co">"""Compute the time over threshold for a 1d or 2d array given a fixed threshold. The</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="co">    time over threshold is defined as the difference between the intersection of the</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="co">    threshold with the segments of the samples: the last - the first segments</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="co">    crossing this threshold define the tot. In case no samples cross the</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="co">    tot, the resulting value is 0.as_integer_ratio</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="co">    </span></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="co">    Parameters</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="co">    ----------</span></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="co">    data: ndarray</span></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="co">        1d or 2d array of shape (n_waveforms, n_samples)</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="co">    threshold: float or int or ndarray (n_waveforms)</span></span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="co">        a fixed threshold for all the waveforms or a set of threshold</span></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">        for each waveform</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="co">    Returns</span></span>
<span id="cb26-17"><a href="#cb26-17"></a><span class="co">    -------</span></span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="co">    out: ndarray</span></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="co">        a 1d array of the time over thresholds of shape (n_waveforms)</span></span>
<span id="cb26-20"><a href="#cb26-20"></a><span class="co">    """</span></span>
<span id="cb26-21"><a href="#cb26-21"></a>    <span class="co"># In case of a 1d array of shape (n_samples), convert it to a 2d</span></span>
<span id="cb26-22"><a href="#cb26-22"></a>    <span class="co"># array of shape (1, n_samples), so that the code can be used for</span></span>
<span id="cb26-23"><a href="#cb26-23"></a>    <span class="co"># both 1d and 2d array</span></span>
<span id="cb26-24"><a href="#cb26-24"></a>    <span class="cf">if</span> data.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb26-25"><a href="#cb26-25"></a>        waveforms <span class="op">=</span> data[<span class="va">None</span>, :]</span>
<span id="cb26-26"><a href="#cb26-26"></a>    <span class="cf">else</span>:</span>
<span id="cb26-27"><a href="#cb26-27"></a>        waveforms <span class="op">=</span> data</span>
<span id="cb26-28"><a href="#cb26-28"></a>    <span class="co"># The same operation for threshold:</span></span>
<span id="cb26-29"><a href="#cb26-29"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(threshold, np.ndarray):</span>
<span id="cb26-30"><a href="#cb26-30"></a>        threshold <span class="op">=</span> np.array([threshold])</span>
<span id="cb26-31"><a href="#cb26-31"></a></span>
<span id="cb26-32"><a href="#cb26-32"></a>    window_length <span class="op">=</span> waveforms.shape[<span class="dv">1</span>]</span>
<span id="cb26-33"><a href="#cb26-33"></a>    </span>
<span id="cb26-34"><a href="#cb26-34"></a>    samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold[:, <span class="va">None</span>]</span>
<span id="cb26-35"><a href="#cb26-35"></a>    <span class="co"># Find the indices xfb and xlb</span></span>
<span id="cb26-36"><a href="#cb26-36"></a>    xfb <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb26-37"><a href="#cb26-37"></a>    <span class="co"># Add np.where condition to handle signal without threshold crossing</span></span>
<span id="cb26-38"><a href="#cb26-38"></a>    xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb26-39"><a href="#cb26-39"></a>    xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb26-40"><a href="#cb26-40"></a>    xlb <span class="op">=</span> np.where(xlb <span class="op">!=</span> window_length <span class="op">-</span> <span class="dv">1</span>, xlb, <span class="dv">0</span>)</span>
<span id="cb26-41"><a href="#cb26-41"></a>    <span class="co"># Taking indices along a 2d array is a bit</span></span>
<span id="cb26-42"><a href="#cb26-42"></a>    <span class="co"># more complicated. There are few different</span></span>
<span id="cb26-43"><a href="#cb26-43"></a>    <span class="co"># ways to do it</span></span>
<span id="cb26-44"><a href="#cb26-44"></a>    yfb <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb26-45"><a href="#cb26-45"></a>    ylb <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb26-46"><a href="#cb26-46"></a></span>
<span id="cb26-47"><a href="#cb26-47"></a>    xfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb26-48"><a href="#cb26-48"></a>    yfa <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb26-49"><a href="#cb26-49"></a>    xla <span class="op">=</span> xlb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb26-50"><a href="#cb26-50"></a>    yla <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>] <span class="op">+</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb26-51"><a href="#cb26-51"></a></span>
<span id="cb26-52"><a href="#cb26-52"></a>    <span class="co"># temp_yf and temp_yl are the arrays to use in case the 'where' condition is False. </span></span>
<span id="cb26-53"><a href="#cb26-53"></a>    <span class="co"># If the 'where' condition is true, then the np.divide() result is used instead</span></span>
<span id="cb26-54"><a href="#cb26-54"></a>    temp_yf, temp_yl <span class="op">=</span> np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), np.zeros_like(ylb, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb26-55"><a href="#cb26-55"></a>    xf <span class="op">=</span> xfb <span class="op">+</span> (xfa <span class="op">-</span> xfb) <span class="op">*</span> (np.divide((threshold <span class="op">-</span> yfb) , (yfa <span class="op">-</span> yfb), out<span class="op">=</span>temp_yf, where<span class="op">=</span>(yfa <span class="op">-</span> yfb) <span class="op">!=</span> <span class="dv">0</span>))</span>
<span id="cb26-56"><a href="#cb26-56"></a>    xl <span class="op">=</span> xlb <span class="op">+</span> (xla <span class="op">-</span> xlb) <span class="op">*</span> (np.divide((threshold <span class="op">-</span> ylb) , (yla <span class="op">-</span> ylb), out<span class="op">=</span>temp_yl, where<span class="op">=</span>(yla <span class="op">-</span> ylb) <span class="op">!=</span> <span class="dv">0</span>))</span>
<span id="cb26-57"><a href="#cb26-57"></a>    time_over_threshold <span class="op">=</span> xl <span class="op">-</span> xf</span>
<span id="cb26-58"><a href="#cb26-58"></a></span>
<span id="cb26-59"><a href="#cb26-59"></a>    <span class="cf">return</span> time_over_threshold</span>
<span id="cb26-60"><a href="#cb26-60"></a></span>
<span id="cb26-61"><a href="#cb26-61"></a>waveform_test <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb26-62"><a href="#cb26-62"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb26-63"><a href="#cb26-63"></a>tot <span class="op">=</span> compute_time_over_threshold(waveform_test, threshold_test)</span>
<span id="cb26-64"><a href="#cb26-64"></a>expected_tot <span class="op">=</span> np.array([<span class="dv">4</span>])</span>
<span id="cb26-65"><a href="#cb26-65"></a>tot, expected_tot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="508">
<pre><code>(array([0.]), array([4]))</code></pre>
</div>
</div>
<p>Here I wrapped everything into a function and added few initial lines of codes to transform a 1d array into a 2d array with the first dimension set to 1. This allows me to reuse the same code for the case in which we have a single waveform or multiple ones. The same applies for the threshold: if it is a scalar then it’s converted to a 1d array.</p>
<p>Let’s test the function with a simple case: there are no points going below the threshold:</p>
<div class="cell" data-execution_count="504">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb28-2"><a href="#cb28-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>tot <span class="op">=</span> compute_time_over_threshold(waveform_test, threshold_test)</span>
<span id="cb28-4"><a href="#cb28-4"></a>expected_tot <span class="op">=</span> np.array([<span class="dv">0</span>])</span>
<span id="cb28-5"><a href="#cb28-5"></a>tot, expected_tot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="504">
<pre><code>(array([0.]), array([0]))</code></pre>
</div>
</div>
<p>So far so good. Now I want to test a simple case in which the time over threshold should be a simple scalar value.</p>
<div class="cell" data-execution_count="505">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb30-2"><a href="#cb30-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>tot <span class="op">=</span> compute_time_over_threshold(waveform_test, threshold_test)</span>
<span id="cb30-4"><a href="#cb30-4"></a>expected_tot <span class="op">=</span> np.array([<span class="dv">3</span>])</span>
<span id="cb30-5"><a href="#cb30-5"></a>tot, expected_tot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="505">
<pre><code>(array([3.]), array([3]))</code></pre>
</div>
</div>
<p>The time over threshold is working fine in this case. Few other corners cases: all samples are below threshold, so the computed time over threshold should be equal to the window length</p>
<div class="cell" data-execution_count="507">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>waveform_test <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb32-2"><a href="#cb32-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>tot <span class="op">=</span> compute_time_over_threshold(waveform_test, threshold_test)</span>
<span id="cb32-4"><a href="#cb32-4"></a>expected_tot <span class="op">=</span> np.array([<span class="dv">4</span>])</span>
<span id="cb32-5"><a href="#cb32-5"></a>tot, expected_tot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="507">
<pre><code>(array([0.]), array([4]))</code></pre>
</div>
</div>
<p>In this case the time over threshold is not computed properly. The issue arises due to the way <code>xlb</code> is handled. In particular, in line <code>40</code>, the part <code>xlb = np.where(xlb != window_length - 1, xlb, 0)</code> is setting the values of <code>xlb</code> to 0 in case <code>xlb == window_length - 1</code>. The problem is that there are two cases in which <code>xlb</code> could be equal to <code>window_length - 1</code>. One case is when the last sample is actually the last crossing the threshold. The second is the one where no samples are crossing the threshold, so <code>np.argmax()</code> returns the first item of the array, which in the reversed case is <code>window_length - 1</code>.</p>
<p>For this reason, it is important to distinguish the two cases and handle them separately. In the case of two conditions <code>xlb == window_length - 1</code> and <code>np.all(samples_below_threshold == True, axis=1)</code> happening at the same time then all the samples are already below the threshold, thus the time over threshold will be equal to the <code>window_length</code>. Instead, in the case of <code>xlb == window_length - 1</code> and <code>np.any(samples_below_threshold == True, axis=1)</code> it means there is at least one sample below the threshold so we can calculate the time over threshold as expected. It could be all the samples but in that case we would fall into the previous condition, so it should be already handled.</p>
<p>Additionally, <code>xla</code> should be also modified: if <code>xlb == window_length - 1</code> then it means the last sample is still below the threshold, so <code>xla</code> can be set to be equal to <code>xlb</code> in order to compute the time over threshold on the last point (which is a segment delimited by <span class="math inline">\(x_{la}, x_{lb}\)</span>, so a segment with length 0). Otherwsise, <code>xlb</code> can be set to <code>xla + 1</code> as usual.</p>
<p>Below the updated code:</p>
<div class="cell" data-execution_count="509">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">def</span> compute_time_over_threshold(data: np.ndarray, threshold: <span class="bu">float</span> <span class="op">|</span> <span class="bu">int</span> <span class="op">|</span> np.ndarray) <span class="op">-&gt;</span> np.ndarray: </span>
<span id="cb34-2"><a href="#cb34-2"></a>    <span class="co">"""Compute the time over threshold for a 1d or 2d array given a fixed threshold. The</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="co">    time over threshold is defined as the difference between the intersection of the</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="co">    threshold with the segments of the samples: the last - the first segments</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="co">    crossing this threshold define the tot. In case no samples cross the</span></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="co">    tot, the resulting value is 0.as_integer_ratio</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="co">    </span></span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="co">    Parameters</span></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="co">    ----------</span></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="co">    data: ndarray</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="co">        1d or 2d array of shape (n_waveforms, n_samples)</span></span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="co">    threshold: float or int or ndarray (n_waveforms)</span></span>
<span id="cb34-13"><a href="#cb34-13"></a><span class="co">        a fixed threshold for all the waveforms or a set of threshold</span></span>
<span id="cb34-14"><a href="#cb34-14"></a><span class="co">        for each waveform</span></span>
<span id="cb34-15"><a href="#cb34-15"></a></span>
<span id="cb34-16"><a href="#cb34-16"></a><span class="co">    Returns</span></span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="co">    -------</span></span>
<span id="cb34-18"><a href="#cb34-18"></a><span class="co">    out: ndarray</span></span>
<span id="cb34-19"><a href="#cb34-19"></a><span class="co">        a 1d array of the time over thresholds of shape (n_waveforms)</span></span>
<span id="cb34-20"><a href="#cb34-20"></a><span class="co">    """</span></span>
<span id="cb34-21"><a href="#cb34-21"></a>    <span class="co"># In case of a 1d array of shape (n_samples), convert it to a 2d</span></span>
<span id="cb34-22"><a href="#cb34-22"></a>    <span class="co"># array of shape (1, n_samples), so that the code can be used for</span></span>
<span id="cb34-23"><a href="#cb34-23"></a>    <span class="co"># both 1d and 2d array</span></span>
<span id="cb34-24"><a href="#cb34-24"></a>    <span class="cf">if</span> data.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb34-25"><a href="#cb34-25"></a>        waveforms <span class="op">=</span> data[<span class="va">None</span>, :]</span>
<span id="cb34-26"><a href="#cb34-26"></a>    <span class="cf">else</span>:</span>
<span id="cb34-27"><a href="#cb34-27"></a>        waveforms <span class="op">=</span> data</span>
<span id="cb34-28"><a href="#cb34-28"></a>    <span class="co"># The same operation for threshold:</span></span>
<span id="cb34-29"><a href="#cb34-29"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(threshold, np.ndarray):</span>
<span id="cb34-30"><a href="#cb34-30"></a>        threshold <span class="op">=</span> np.array([threshold])</span>
<span id="cb34-31"><a href="#cb34-31"></a>    </span>
<span id="cb34-32"><a href="#cb34-32"></a>    samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold[:, <span class="va">None</span>]</span>
<span id="cb34-33"><a href="#cb34-33"></a>    window_length <span class="op">=</span> waveforms.shape[<span class="dv">1</span>]</span>
<span id="cb34-34"><a href="#cb34-34"></a></span>
<span id="cb34-35"><a href="#cb34-35"></a>    xfb <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb34-36"><a href="#cb34-36"></a>    xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb34-37"><a href="#cb34-37"></a>    xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb34-38"><a href="#cb34-38"></a>    <span class="co"># Notice I removed the np.where() condition on xlb</span></span>
<span id="cb34-39"><a href="#cb34-39"></a></span>
<span id="cb34-40"><a href="#cb34-40"></a>    yfb <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb34-41"><a href="#cb34-41"></a>    ylb <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb34-42"><a href="#cb34-42"></a></span>
<span id="cb34-43"><a href="#cb34-43"></a>    xfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb34-44"><a href="#cb34-44"></a>    yfa <span class="op">=</span> np.take_along_axis(waveforms, xfa[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb34-45"><a href="#cb34-45"></a>    <span class="co"># Here I put a condition on xla: if xlb is the last item, then xla</span></span>
<span id="cb34-46"><a href="#cb34-46"></a>    <span class="co"># should be the same as xlb, so the segment (xlb-xla) is of length 0</span></span>
<span id="cb34-47"><a href="#cb34-47"></a>    xla <span class="op">=</span> np.where(xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>, xlb, xlb <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb34-48"><a href="#cb34-48"></a>    yla <span class="op">=</span> np.take_along_axis(waveforms, xla[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb34-49"><a href="#cb34-49"></a></span>
<span id="cb34-50"><a href="#cb34-50"></a>    xf <span class="op">=</span> xfb <span class="op">+</span> (np.divide((threshold <span class="op">-</span> yfb) , (yfa <span class="op">-</span> yfb), out<span class="op">=</span>np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), where<span class="op">=</span>((yfa <span class="op">-</span> yfb) <span class="op">!=</span> <span class="dv">0</span>)))</span>
<span id="cb34-51"><a href="#cb34-51"></a>    xl <span class="op">=</span> xlb <span class="op">+</span> (np.divide((threshold <span class="op">-</span> ylb) , (yla <span class="op">-</span> ylb), out<span class="op">=</span>np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), where<span class="op">=</span>((yla <span class="op">-</span> ylb) <span class="op">!=</span> <span class="dv">0</span>)))</span>
<span id="cb34-52"><a href="#cb34-52"></a>    <span class="co"># Use np.select() as a case statement:</span></span>
<span id="cb34-53"><a href="#cb34-53"></a>    time_over_threshold <span class="op">=</span> np.select(condlist<span class="op">=</span>[</span>
<span id="cb34-54"><a href="#cb34-54"></a>        (xlb <span class="op">!=</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">all</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)),  <span class="co"># all points crossing threshold</span></span>
<span id="cb34-55"><a href="#cb34-55"></a>        (xlb <span class="op">!=</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">any</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)),  <span class="co"># at least one point crossing threshold</span></span>
<span id="cb34-56"><a href="#cb34-56"></a>        (xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">all</span>(samples_below_threshold <span class="op">==</span> <span class="va">False</span>, axis<span class="op">=</span><span class="dv">1</span>)), <span class="co"># no real points crossing threshold</span></span>
<span id="cb34-57"><a href="#cb34-57"></a>        (xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">any</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)), <span class="co"># last point crossing threshold</span></span>
<span id="cb34-58"><a href="#cb34-58"></a>    ], choicelist<span class="op">=</span>[</span>
<span id="cb34-59"><a href="#cb34-59"></a>        window_length,</span>
<span id="cb34-60"><a href="#cb34-60"></a>        xl<span class="op">-</span>xf,</span>
<span id="cb34-61"><a href="#cb34-61"></a>        <span class="dv">0</span>, </span>
<span id="cb34-62"><a href="#cb34-62"></a>        xl<span class="op">-</span>xf</span>
<span id="cb34-63"><a href="#cb34-63"></a>    ])</span>
<span id="cb34-64"><a href="#cb34-64"></a>    </span>
<span id="cb34-65"><a href="#cb34-65"></a>    <span class="cf">return</span> time_over_threshold</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As you can see I removed the <code>np.where()</code> condition onf <code>xlb</code> and added one on <code>xla</code>. If I didn’t, then when <code>xlb</code> is equal to <code>window_length - 1</code>, <code>xla</code> would be equal to <code>window_length</code>, resulting in an error when trying to access the array since the last item is at <code>window_length - 1</code>.</p>
<p>Also, I added <code>np.select()</code> which I usually think of as a n-dimensional version of a case statement. In case <code>xlb != window_length - 1</code> there could be either all points crossing the threshold or at least one, so the time over threshold would be either the whole <code>window_length</code> or the computed <code>xl - xf</code> value.</p>
<p>In case <code>xlb == window_length - 1</code> then there could be either no points at all crossing the threshold (<code>time_over_threshold = 0</code>) or there could be only the lat one crossing it, so the time over threshold would be again computed in the standard way of <code>xl - xf</code>.</p>
<p>Now the case in which the first sample is already below the threshold but not the last is correctly handled:</p>
<div class="cell" data-execution_count="511">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a>waveform_test <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb35-2"><a href="#cb35-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>tot <span class="op">=</span> compute_time_over_threshold(waveform_test, threshold_test)</span>
<span id="cb35-4"><a href="#cb35-4"></a>expected_tot <span class="op">=</span> np.array([<span class="fl">2.5</span>])</span>
<span id="cb35-5"><a href="#cb35-5"></a>tot, expected_tot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="511">
<pre><code>(array([2.5]), array([2.5]))</code></pre>
</div>
</div>
<p>Here below you can find the final the final code I use for the time over threshold calculation and few test cases:</p>
<div class="cell" data-execution_count="404">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">def</span> compute_time_over_threshold(data: np.ndarray, threshold: <span class="bu">float</span> <span class="op">|</span> <span class="bu">int</span> <span class="op">|</span> np.ndarray) <span class="op">-&gt;</span> np.ndarray: </span>
<span id="cb37-2"><a href="#cb37-2"></a>    <span class="co">"""Compute the time over threshold for a 1d or 2d array given a fixed threshold. The</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="co">    time over threshold is defined as the difference between the intersection of the</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="co">    threshold with the segments of the samples: the last - the first segments</span></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="co">    crossing this threshold define the tot. In case no samples cross the</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="co">    tot, the resulting value is 0.as_integer_ratio</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="co">    </span></span>
<span id="cb37-8"><a href="#cb37-8"></a><span class="co">    Parameters</span></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="co">    ----------</span></span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="co">    data: ndarray</span></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="co">        1d or 2d array of shape (n_waveforms, n_samples)</span></span>
<span id="cb37-12"><a href="#cb37-12"></a><span class="co">    threshold: float or int or ndarray (n_waveforms)</span></span>
<span id="cb37-13"><a href="#cb37-13"></a><span class="co">        a fixed threshold for all the waveforms or a set of threshold</span></span>
<span id="cb37-14"><a href="#cb37-14"></a><span class="co">        for each waveform</span></span>
<span id="cb37-15"><a href="#cb37-15"></a></span>
<span id="cb37-16"><a href="#cb37-16"></a><span class="co">    Returns</span></span>
<span id="cb37-17"><a href="#cb37-17"></a><span class="co">    -------</span></span>
<span id="cb37-18"><a href="#cb37-18"></a><span class="co">    out: ndarray</span></span>
<span id="cb37-19"><a href="#cb37-19"></a><span class="co">        a 1d array of the time over thresholds of shape (n_waveforms)</span></span>
<span id="cb37-20"><a href="#cb37-20"></a><span class="co">    """</span></span>
<span id="cb37-21"><a href="#cb37-21"></a>    <span class="co"># In case of a 1d array of shape (n_samples), convert it to a 2d</span></span>
<span id="cb37-22"><a href="#cb37-22"></a>    <span class="co"># array of shape (1, n_samples), so that the code can be used for</span></span>
<span id="cb37-23"><a href="#cb37-23"></a>    <span class="co"># both 1d and 2d array</span></span>
<span id="cb37-24"><a href="#cb37-24"></a>    <span class="cf">if</span> data.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb37-25"><a href="#cb37-25"></a>        waveforms <span class="op">=</span> data[<span class="va">None</span>, :]</span>
<span id="cb37-26"><a href="#cb37-26"></a>    <span class="cf">else</span>:</span>
<span id="cb37-27"><a href="#cb37-27"></a>        waveforms <span class="op">=</span> data</span>
<span id="cb37-28"><a href="#cb37-28"></a>    <span class="co"># The same operation for threshold:</span></span>
<span id="cb37-29"><a href="#cb37-29"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(threshold, np.ndarray):</span>
<span id="cb37-30"><a href="#cb37-30"></a>        threshold <span class="op">=</span> np.array([threshold])</span>
<span id="cb37-31"><a href="#cb37-31"></a>    </span>
<span id="cb37-32"><a href="#cb37-32"></a>    samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold[:, <span class="va">None</span>]</span>
<span id="cb37-33"><a href="#cb37-33"></a>    window_length <span class="op">=</span> waveforms.shape[<span class="dv">1</span>]</span>
<span id="cb37-34"><a href="#cb37-34"></a></span>
<span id="cb37-35"><a href="#cb37-35"></a>    xfb <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb37-36"><a href="#cb37-36"></a>    xfb <span class="op">=</span> np.where(xfb <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>, xfb, <span class="dv">0</span>)</span>
<span id="cb37-37"><a href="#cb37-37"></a>    xlb <span class="op">=</span> window_length <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb37-38"><a href="#cb37-38"></a></span>
<span id="cb37-39"><a href="#cb37-39"></a>    yfb <span class="op">=</span> np.take_along_axis(waveforms, xfb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb37-40"><a href="#cb37-40"></a>    ylb <span class="op">=</span> np.take_along_axis(waveforms, xlb[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb37-41"><a href="#cb37-41"></a></span>
<span id="cb37-42"><a href="#cb37-42"></a>    xfa <span class="op">=</span> xfb <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb37-43"><a href="#cb37-43"></a>    yfa <span class="op">=</span> np.take_along_axis(waveforms, xfa[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb37-44"><a href="#cb37-44"></a>    xla <span class="op">=</span> np.where(xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>, xlb, xlb <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb37-45"><a href="#cb37-45"></a>    yla <span class="op">=</span> np.take_along_axis(waveforms, xla[:, <span class="va">None</span>], axis<span class="op">=</span><span class="dv">1</span>).flatten()</span>
<span id="cb37-46"><a href="#cb37-46"></a></span>
<span id="cb37-47"><a href="#cb37-47"></a>    xf <span class="op">=</span> xfb <span class="op">+</span> (np.divide((threshold <span class="op">-</span> yfb) , (yfa <span class="op">-</span> yfb), out<span class="op">=</span>np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), where<span class="op">=</span>((yfa <span class="op">-</span> yfb) <span class="op">!=</span> <span class="dv">0</span>)))</span>
<span id="cb37-48"><a href="#cb37-48"></a>    xl <span class="op">=</span> xlb <span class="op">+</span> (np.divide((threshold <span class="op">-</span> ylb) , (yla <span class="op">-</span> ylb), out<span class="op">=</span>np.zeros_like(yfa, dtype<span class="op">=</span><span class="st">'float64'</span>), where<span class="op">=</span>((yla <span class="op">-</span> ylb) <span class="op">!=</span> <span class="dv">0</span>)))</span>
<span id="cb37-49"><a href="#cb37-49"></a>    time_over_threshold <span class="op">=</span> np.select(condlist<span class="op">=</span>[</span>
<span id="cb37-50"><a href="#cb37-50"></a>        (xlb <span class="op">!=</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">all</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)),  <span class="co"># all points crossing threshold</span></span>
<span id="cb37-51"><a href="#cb37-51"></a>        (xlb <span class="op">!=</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">any</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)),  <span class="co"># at least one point crossing threshold</span></span>
<span id="cb37-52"><a href="#cb37-52"></a>        (xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">all</span>(samples_below_threshold <span class="op">==</span> <span class="va">False</span>, axis<span class="op">=</span><span class="dv">1</span>)), <span class="co"># no real point crossing threshold</span></span>
<span id="cb37-53"><a href="#cb37-53"></a>        (xlb <span class="op">==</span> window_length <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (np.<span class="bu">any</span>(samples_below_threshold <span class="op">==</span> <span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)), <span class="co"># last point</span></span>
<span id="cb37-54"><a href="#cb37-54"></a>    ], choicelist<span class="op">=</span>[</span>
<span id="cb37-55"><a href="#cb37-55"></a>        window_length,</span>
<span id="cb37-56"><a href="#cb37-56"></a>        xl<span class="op">-</span>xf,</span>
<span id="cb37-57"><a href="#cb37-57"></a>        <span class="dv">0</span>,</span>
<span id="cb37-58"><a href="#cb37-58"></a>        xl<span class="op">-</span>xf</span>
<span id="cb37-59"><a href="#cb37-59"></a>    ])</span>
<span id="cb37-60"><a href="#cb37-60"></a>    </span>
<span id="cb37-61"><a href="#cb37-61"></a>    <span class="cf">return</span> time_over_threshold</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Few test cases here below:</p>
<div class="cell" data-execution_count="405">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb38-2"><a href="#cb38-2"></a>threshold_test <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="405">
<pre><code>array([8.])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="406">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb40-2"><a href="#cb40-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="dv">10</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="406">
<pre><code>array([0.])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="407">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a>waveform_test <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb42-2"><a href="#cb42-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="407">
<pre><code>array([4.5])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="408">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">4</span>])</span>
<span id="cb44-2"><a href="#cb44-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="dv">2</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="408">
<pre><code>array([5.66666667])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="409">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb46-2"><a href="#cb46-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="dv">2</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="409">
<pre><code>array([3.16666667])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="413">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a>waveform_test <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb48-2"><a href="#cb48-2"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">2.2</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="413">
<pre><code>array([3.4])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="414">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1"></a>waveform_test <span class="op">=</span> np.array([</span>
<span id="cb50-2"><a href="#cb50-2"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb50-3"><a href="#cb50-3"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="fl">1.5</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb50-4"><a href="#cb50-4"></a>])</span>
<span id="cb50-5"><a href="#cb50-5"></a>threshold_test <span class="op">=</span> <span class="op">-</span><span class="fl">2.2</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="414">
<pre><code>array([3.13333333, 0.        ])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="343">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a>waveform_test <span class="op">=</span> np.array([</span>
<span id="cb52-2"><a href="#cb52-2"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb52-3"><a href="#cb52-3"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="fl">1.5</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb52-4"><a href="#cb52-4"></a>])</span>
<span id="cb52-5"><a href="#cb52-5"></a>threshold_test <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">2.2</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb52-6"><a href="#cb52-6"></a>compute_time_over_threshold(waveform_test, threshold_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="343">
<pre><code>array([3.13333333, 0.61904762])</code></pre>
</div>
</div>
</section>
</section>
<section id="why-i-needed-linear-interpolation" class="level1">
<h1>Why I needed linear interpolation</h1>
<p>The readout system I use to sample signal is poorly resoluted compared to the average time over threshold of the signals, so I wanted to have a linear interpolation to allow me to compute proper distributions of the time over threshold. This is possible thanks to the intrinsic time jitter of the digitizer which is of few order of magnitude lower than its sampling frequency.</p>
<p>For example, a digitizer can have a sampling frequency of 500 Ms/s but a time jitter (or time resolution) of 50 ps.</p>
<p>The two plots here below shows the difference between using the simple version of the time over threshold and the implemented one.</p>
<div class="cell" data-execution_count="512">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a>n_waveforms, n_samples <span class="op">=</span> <span class="dv">10_000</span>, <span class="dv">20</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>threshold <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="co"># Generated some fake data of 10_000 waveforms of 20 samples each</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="co"># with values between -10 and 0</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>x <span class="op">=</span> np.tile(np.arange(n_samples), n_waveforms).reshape((n_waveforms, n_samples))</span>
<span id="cb54-6"><a href="#cb54-6"></a>noise <span class="op">=</span> np.random.randn(n_waveforms, n_samples) <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb54-7"><a href="#cb54-7"></a>waveforms <span class="op">=</span> <span class="fl">5.5</span> <span class="op">*</span> (x<span class="op">-</span><span class="dv">10</span>) <span class="op">+</span> (x<span class="op">-</span><span class="dv">10</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">30</span>  <span class="op">+</span> noise</span>
<span id="cb54-8"><a href="#cb54-8"></a></span>
<span id="cb54-9"><a href="#cb54-9"></a><span class="co"># Simple version of the time over threshold</span></span>
<span id="cb54-10"><a href="#cb54-10"></a>samples_below_threshold <span class="op">=</span> waveforms <span class="op">&lt;</span> threshold</span>
<span id="cb54-11"><a href="#cb54-11"></a>first_items <span class="op">=</span> np.argmax(samples_below_threshold, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb54-12"><a href="#cb54-12"></a>last_items <span class="op">=</span> waveforms.shape[<span class="dv">1</span>] <span class="op">-</span> np.argmax(samples_below_threshold[:, ::<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=</span><span class="dv">1</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb54-13"><a href="#cb54-13"></a>simple_tot <span class="op">=</span> last_items <span class="op">-</span> first_items</span>
<span id="cb54-14"><a href="#cb54-14"></a><span class="co"># Linearly interpolated version of the time over threshold</span></span>
<span id="cb54-15"><a href="#cb54-15"></a>interpolated_tot <span class="op">=</span> compute_time_over_threshold(waveforms, threshold)</span>
<span id="cb54-16"><a href="#cb54-16"></a></span>
<span id="cb54-17"><a href="#cb54-17"></a><span class="co"># Plot the two time over threshold distributions</span></span>
<span id="cb54-18"><a href="#cb54-18"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb54-19"><a href="#cb54-19"></a>ax <span class="op">=</span> axs[<span class="dv">0</span>]</span>
<span id="cb54-20"><a href="#cb54-20"></a>ax.plot(waveforms[:<span class="dv">100</span>, :].T, linewidth<span class="op">=</span><span class="fl">0.3</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb54-21"><a href="#cb54-21"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'Waveforms'</span>, xlabel<span class="op">=</span><span class="st">'Time samples'</span>, ylabel<span class="op">=</span><span class="st">'ADC value'</span>)</span>
<span id="cb54-22"><a href="#cb54-22"></a></span>
<span id="cb54-23"><a href="#cb54-23"></a>ax <span class="op">=</span> axs[<span class="dv">1</span>]</span>
<span id="cb54-24"><a href="#cb54-24"></a>ax.hist(simple_tot, bins<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">1</span>), histtype<span class="op">=</span><span class="st">'step'</span>, label<span class="op">=</span><span class="ss">f'Simple. Mean: </span><span class="sc">{</span>simple_tot<span class="sc">.</span>mean()<span class="sc">:.1f}</span><span class="ss">'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-25"><a href="#cb54-25"></a>ax.hist(interpolated_tot, bins<span class="op">=</span><span class="st">"auto"</span>, histtype<span class="op">=</span><span class="st">'step'</span>, label<span class="op">=</span><span class="ss">f'Interpolated. Mean: </span><span class="sc">{</span>interpolated_tot<span class="sc">.</span>mean()<span class="sc">:.1f}</span><span class="ss">'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-26"><a href="#cb54-26"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'Time Over Threshold distribution'</span>, xlabel<span class="op">=</span><span class="st">'Time [ns]'</span>, ylabel<span class="op">=</span><span class="st">'Normalized counts'</span>)</span>
<span id="cb54-27"><a href="#cb54-27"></a>ax.legend()</span>
<span id="cb54-28"><a href="#cb54-28"></a></span>
<span id="cb54-29"><a href="#cb54-29"></a>fig.tight_layout()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-31-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It is easily visible that with a set of synthetic signals the time resolution computed with the simple sampling is different from the one computed with a linear interpolation.</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>In this post I have tried to calculate the time over threshold in the “classical” way, but also by linearly interpolating the threshold with the points of the sampled signal to achieve a better resolution. The 1-dimensional case is fairly straight forward, but the 2-dimensional case had me think a bit about the best way to implement the solution.</p>
<p>Perhaps there are better or easier ways to do this but I couldn’t find anything on the internet so I had to figure it out by myself. If anyone comes up with a cleaner or better solution I will update this poit.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="grigolet/blog-comments" data-repo-id="R_kgDOH9KztA" data-category="General" data-category-id="DIC_kwDOH9KztM4CRSJC" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>