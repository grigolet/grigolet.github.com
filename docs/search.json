[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Gianluca Rigoletti's Blog",
    "section": "",
    "text": "Multiple Y axes with matplotlib\n\n\nBecause sometimes right y axes are not enough\n\n\n\n\npython\n\n\nmatplotlib\n\n\nplot\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nSep 8, 2022\n\n\n3 min\n\n\n\n\n\n\n\n\nA post made from a jupyter notebook\n\n\nOr how I fell in love with Quarto\n\n\n\n\njupyter\n\n\nnotebook\n\n\npython\n\n\nquarto\n\n\n\n\n\n\n\n\n\n\n\nSep 7, 2022\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/plots-with-multiple-y-axes/index.html",
    "href": "posts/plots-with-multiple-y-axes/index.html",
    "title": "Multiple Y axes with matplotlib",
    "section": "",
    "text": "When working with gas systems I make intense use of the WinCC-OA trending tool, which allows to plot up to 8 time series on the same panel. Each time series tpyically corresponds to the value read by a sensor of a plant so it may have different units and range. The trending tool allows to have multiple Y axes on the left side which can be adjusted in terms of range and offset.\nI find this feature particularly helpful, especially when there is the need to quickly and explore and correlate readings of sensor from different parts of the plant\nTools like matplotlib and plotly make it easy to work with multiple series plotted on the same data but I found a bit cumbersome trying to visualize data having different scales on the same plot.\nAssuming we have a very simple set of \\((x, y_n)\\) series a simple plot with matplotlib may look like this:\nNote that in Figure Figure 1 each time series has a different standard deviation, thus different ranges may be needed. This is often easily accomplished by plotting each series in a different subplots. However, subplots make it more difficult to visually compare and align series, especially when time-based. For example, see subplots here:\nHere I have added an offset to each series. Two series, y1 and y3 have a change point at the same index, while the other two have a change point at slightly different xs. We could plot each series in a subplots, perhaps vertically stacked:\nIn figure Figure 2 you can see that each series as an offset when adding a proper range on the y axis. However, it is still a bit difficult to understand the real indexes of the offset. I would like to understand which come first and which comes later."
  },
  {
    "objectID": "posts/plots-with-multiple-y-axes/index.html#adding-multiple-y-axes-to-matplotlib-plots",
    "href": "posts/plots-with-multiple-y-axes/index.html#adding-multiple-y-axes-to-matplotlib-plots",
    "title": "Multiple Y axes with matplotlib",
    "section": "Adding multiple Y axes to matplotlib plots",
    "text": "Adding multiple Y axes to matplotlib plots\nWe can starting adding multiple axes by taking inspiration from the Matplotib documentation using spines, Parasite Axes and another Parasite axis demo.\nThe idea is to use ax.twinx() to create an additional axes. As the documentation says, > Create a new Axes with an invisible x-axis and an independent y-axis positioned opposite to the original one (i.e. at right).\nAlthough twinx() is used to create a secondary axis on the right position I could use it to create a secondary axis and leave the spines of the axis only on the left. I can use set_position() on the spines object to shift the spines on left:\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax3 = ax1.twinx()\nax4 = ax1.twinx()\naxs = [ax1, ax2, ax3, ax4]\n\nfor ix, (ax, y) in enumerate(zip(axs, series)):\n    ax.plot(x, y, label=f'y{ix}', color=f'C{ix}')\nax.legend();\n\n\n\n\nFigure 3: Single plot with multiple series and secondary axes.\n\n\n\n\nAs you can see in Figure Figure 3 we can understand the index at which each change point of the series is happening. The only issue is that the y axes on the right are overlapping between each other.\nMy goal is to have these secondary y-axes on the left for easier reading. Actually, if you inspect the source of how twinx() is defined, it calls Axes._make_twin_axes() and sets later the tick position on the right using YAxis.tick_right() and YAxis.set_label_position('right'). It would be nice if twinx() would not assume that we want the axes to the right and instead allowed to pass a parameter which decised the position.\nHere below I leave a minimum working example I could think of:\n\nfig, axes = plt.subplots()\nfor ix, y in enumerate(series):\n    # If we have to plot the first series we use \n    # The axes created by plt.subplots() earlier\n    if ix == 0: \n        ax = axes\n    else:\n        # It's not the first series: we need to\n        # create a twin axes\n        ax = axes.twinx()\n    # Set the ticks of the axis to the left\n    ax.yaxis.tick_left()\n    # Set the labels of the axes to the lef\n    ax.yaxis.set_label_position('left')\n    ax.yaxis.set_offset_position('left')\n    # Offset the position of he ticks and labels\n    # by some % of the axes avoid overlapping of axes\n    ax.spines['left'].set_position(('outward', 40 * ix))\n    # Plot the actual data\n    ax.plot(x, y, color=f'C{ix}')\n    ax.spines['left'].set_color(f'C{ix}')\n    ax.tick_params(axis='y', colors=f'C{ix}')\n\n\n\n\nEt voilà, here I have a plot similar to the WinCC-OA one. I could improve the plot a bit by using the same number of ticks for each axes. I would do this using the LinearLocator class:\n\n\nCode\nimport matplotlib.ticker as mt\n\nfig, axes = plt.subplots()\nfor ix, y in enumerate(series):\n    # If we have to plot the first series we use \n    # The axes created by plt.subplots() earlier\n    if ix == 0: \n        ax = axes\n    else:\n        # It's not the first series: we need to\n        # create a twin axes\n        ax = axes.twinx()\n    # Set the ticks of the axis to the left\n    ax.yaxis.tick_left()\n    # Set the labels of the axes to the left\n    ax.yaxis.set_label_position('left')\n    ax.yaxis.set_offset_position('left')\n    # Offset the position of he ticks and labels\n    # by some % of the axes avoid overlapping of axes\n    ax.spines['left'].set_position(('outward', 40 * ix))\n    # Plot the actual data\n    ax.plot(x, y, color=f'C{ix}')\n    # Set the colors of the ticks, labels and spines to be\n    # the same of the associated series\n    ax.spines['left'].set_color(f'C{ix}')\n    ax.tick_params(axis='y', colors=f'C{ix}')\n    # Use a tick locator to have the same number of ticks\n    ax.yaxis.set_major_locator(mt.LinearLocator(11))\n    # And format the labels to have only one digit after the decimals\n    ax.yaxis.set_major_formatter(mt.StrMethodFormatter('{x:.1f}'))"
  },
  {
    "objectID": "posts/plots-with-multiple-y-axes/index.html#conclusions",
    "href": "posts/plots-with-multiple-y-axes/index.html#conclusions",
    "title": "Multiple Y axes with matplotlib",
    "section": "Conclusions",
    "text": "Conclusions\nI find very useful for myself to provide a minimal example of having a plot with multiple axes, though a final plot may require more subtle adjustements. Keypoints to have multiple y axes: * Use twinx() to create an additional axis * Set ticks, labels and offest positions to the right: ax.yaxis.tick_left(), ax.yaxis.set_label_position('left'), ax.yaxis.set_offset_position('left') * Adjust the offset of the spines to the left using points, percentage or data coordinate. In the case of points: ax.spines['left'].set_position() * Change spines, tick and label colors to the same of the series for better readability: ax.spines['left'].set_color(color), ax.tick_params(axis='y', colors=color) * Optionally adjust the number of ticks to be the same for all the axes: use a LinearLocator class with a fixed number of points"
  },
  {
    "objectID": "posts/a-post-with-jupyter-notebook/index.html",
    "href": "posts/a-post-with-jupyter-notebook/index.html",
    "title": "A post made from a jupyter notebook",
    "section": "",
    "text": "Few days ago I found Quarto. I understood it is an authoring framework based on pandoc and that has full support of jupyter notebooks as input files. Since lot of work I carry on at the moment makes a heavy use of jupyter notebook I decided to try Quarto and use it for two main purposes: the first is as a replacement of jupyter nbconvert that I have intensively used to convert notebooks to html pages.\nI saw that Quarto provides much more flexibility on the layout of the text, images and code, which was exactly what I was looking for. The second way I intend to use Quarto is to publish the present content. At the time of writing, this post is written on an index.ipynb file in my local computer using Visual Studio code. I find extremely pleasant to write mixed content and have a tool that transforms it in a post page of a blog website.\nI will showcase here all the features that I have personally found relevant for the posts I am going to write as well, hoping that this post serves as a quick reference (together with the Quarto user guide)."
  },
  {
    "objectID": "posts/a-post-with-jupyter-notebook/index.html#code-cells",
    "href": "posts/a-post-with-jupyter-notebook/index.html#code-cells",
    "title": "A post made from a jupyter notebook",
    "section": "Code cells",
    "text": "Code cells\nCode cells are pretty straightforward: I just have to write code in a cell and it will be executed and the output eventually frozen by Quarto. I found the freeze option particularly useful and I set it to auto at the time of writing. In this way, the notebooks will be re-rendered only if the source code changes.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd \nimport numpy as np\n\nAt the very base you can just enter some code and save it. If you are using quarto preview the jupyter notebook is executed when it saved (and not when a code cell is executed, but this depends on the saving options of jupyter).\nFor instance, we can write some code and let it display some output like this:\n\nclass TestClass:\n    def __init__(self, params) -> None:\n        self.attributes = params\n    \n    def increment(self, param: int) -> int:\n        return param + 1\n\nobj = TestClass('test')\nobj.increment(10)\n\n11\n\n\nSometimes a cell may contain lot of code that makes it difficult for the reader to keep track of the text. In this case folding the code is very helpful and only requires a special comment to be added at the beginning of the code cell:\n#| code-fold: true\n\nclass TestClass:\n    def __init__(self, params) -> None:\n        self.attributes = params\n    \n    def increment(self, param: int) -> int:\n        return param + 1\n\nobj = TestClass('test')\nobj.increment(10)\nHere below the result of the previous snippet of code:\n\n\nCode\nclass TestClass:\n    def __init__(self, params) -> None:\n        self.attributes = params\n    \n    def increment(self, param: int) -> int:\n        return param + 1\n\nobj = TestClass('test')\nobj.increment(10)\n\n\n11\n\n\nNote that the output of the cell is not folded. This is particularly useful if you have lot of code printing out a plot for example: the code will be folded but the plot will be visible anyway.\nSome other time I wish to completely hide the code while keeping the output visible. In this case the option echo: false does the job:\n#| echo: false\nplt.plot([1,2,3], [4,5,6], 'ro');\nHere below the result of the previous snippet of code:\n\n\n\n\n\nCode cells can be also assigned a file name. This is particularly helpful when there is a post that needs to tackle code among several files. As an example you can have something like:\n#| filename: test.py\n\nclass A:\n    pass\nAnd this would be rendered to:\n\n\n\ntest.py\n\nclass A:\n    pass"
  },
  {
    "objectID": "posts/a-post-with-jupyter-notebook/index.html#controlling-figures-layout",
    "href": "posts/a-post-with-jupyter-notebook/index.html#controlling-figures-layout",
    "title": "A post made from a jupyter notebook",
    "section": "Controlling figures layout",
    "text": "Controlling figures layout\nI find particularly useful the way Quarto helps treating outputs for code cells, especially laying out figures resulting from a code output. Often times I have big plots that I would like to take all the available horizontal space in the page. In this case I can use #| column: screen together with #| fig-align: center on the code cell\n#| column: screen\n#| fig-align: center\nfig, ax = plt.subplots(figsize=(8, 5), dpi=150)\nax.plot(range(10), [1,2,3,2,1,2,2,31,1,2])\n\n\n\n\n\n\n\n\n\nThere is also support for custom layouts when multiple plots are produced. I typically use matplotlib APIs to lay out multiple plots but this features could be useful for images in general and sometimes with libraries where the layout support for subplots is not straightforward. As an example see this snippet:\n#| layout-ncol: 2\n\nfig, ax = plt.subplots()\nax.plot([1,2,3,4], [4,3,2,3], 'ro-')\n\nfig2, ax2 = plt.subplots()\nax2.plot([1,2,3,4], [4,3,1,32], 'b*--')"
  },
  {
    "objectID": "posts/a-post-with-jupyter-notebook/index.html#conclusions",
    "href": "posts/a-post-with-jupyter-notebook/index.html#conclusions",
    "title": "A post made from a jupyter notebook",
    "section": "Conclusions",
    "text": "Conclusions\nThere are several more features that I think I will be using throughout my journey on this blog. There are also some features related to publications that I want to explore as I would like to understand if I can have some publications ready LaTeX documents from jupyter notebooks\nI found Quarto really easy to use and the documentation is fairly straightforward to follow. I hope to post more interesting findings and customization as I will use it :)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Education\nPhD in particle physics | 2019 - 2022\nUniversité Claude Bernard Lyon I\nMaster degree in physics of the matter | 2017-2019\nUniversità degli Studi di Milano-Bicocca\nBachelor degree in physics of the matter | 2017-2019\nUniversità degli Studi di Milano-Bicocca\n\n\nExperience\nCERN Senior fellow | 2022 CERN, Switzerland\nSoftware developer | 2016-2017 Yperesia, Italy"
  }
]